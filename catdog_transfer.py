# -*- coding: utf-8 -*-
"""CatDog-transfer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XwCCT6P4qjcNZimNKSvo8OdmXPuQd-2X
"""

import numpy as np
import matplotlib.pyplot as plt
import os
import cv2

!pip install kaggle

from google.colab import files
files.upload()

!mkdir -p ~/.kaggle
!cp "kaggle (1).json" ~/.kaggle/kaggle.json
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d tongpython/cat-and-dog

!unzip /content/cat-and-dog.zip -d ./data/

image_path = "/content/data/training_set/training_set/cats/cat.1.jpg"
image = cv2.imread(image_path)
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
plt.imshow(image)

import torch
from torchvision import datasets, transforms
from torch.utils.data import DataLoader


transform = transforms.Compose([
    transforms.Resize((128, 128)),  # mặc định nội suy bilinear
    transforms.ToTensor()
])

train_dataset = datasets.ImageFolder(root='/content/data/training_set/training_set', transform = transform)
test_dataset = datasets.ImageFolder(root='/content/data/test_set/test_set', transform = transform)

image, label = train_dataset[4000]
print(image.shape)
print(label)

train_dataloader = DataLoader(
    dataset = train_dataset,
    batch_size = 16,
    shuffle = True,
    num_workers = 2
)

test_dataloader = DataLoader(
    dataset = test_dataset,
    batch_size = 16,
    shuffle = True,
    num_workers = 2
)

import inspect
import torchvision.models.resnet as resnet
#print(inspect.getsource(resnet.resnet50))  # Xem định nghĩa resnet50
print(inspect.getsource(resnet.ResNet))      # Xem class ResNet

from torchvision.models import resnet50
import torchvision.models as models
import torch.nn as nn

model = resnet50(pretrained=True)
print(model.fc)

model.fc = nn.Linear(in_features=2048, out_features=2, bias=True)
print(model.fc)

for name, param in model.named_parameters():
    if 'fc.' in name:
        param.requires_grad = True
    else:
        param.requires_grad = False

criterion = nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

num_epochs = 20
num_iters = len(train_dataloader)

for epoch in range(num_epochs):
  model.train()
  for i, (image, label) in enumerate(train_dataloader):
      #forward
      outputs = model(image)
      loss_value = criterion(outputs, label)
      print("Epoch {}/{}. Interation {}/{}. Loss {}".format(epoch + 1, num_epochs, i+1,num_iters, loss_value))

      #backward
      optimizer.zero_grad()
      loss_value.backward()
      optimizer.step()

  model.eval()
  correct = 0
  total = 0

  with torch.no_grad():
    for image, label in test_dataloader:
      outputs = model(image)
      _, predicted = torch.max(outputs, 1)
      total += label.size(0)
      correct += (predicted == label).sum().item()
  acc = 100 * correct / total
  print("Epoch {}/{}. Accuracy on test set : {:2f}%".format(epoch+1, num_epochs, acc))

from google.colab import files
files.upload()